<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>PPrintEngine (pprint.PPrintEngine)</title><link rel="stylesheet" href="../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">pprint</a> &#x00BB; PPrintEngine</nav><header class="odoc-preamble"><h1>Module <code><span>PPrintEngine</span></code></h1><p><code>PPrint</code> is an OCaml library for <b>pretty-printing textual documents</b>. It takes care of <b>indentation and line breaks</b>, and is typically used to <b>pretty-print code</b>.</p></header><nav class="odoc-toc"><ul><li><a href="#building">Building Documents</a><ul><li><a href="#atomic-documents">Atomic Documents</a></li><li><a href="#blanks-and-newlines">Blanks and Newlines</a></li><li><a href="#composite-documents">Composite Documents</a></li></ul></li><li><a href="#inspecting">Inspecting Documents</a></li><li><a href="#rendering">Rendering Documents</a></li><li><a href="#defining">Defining Custom Documents</a></li></ul></nav><div class="odoc-content"><h2 id="building"><a href="#building" class="anchor"></a>Building Documents</h2><div class="odoc-spec"><div class="spec type anchored" id="type-document"><a href="#type-document" class="anchor"></a><code><span><span class="keyword">type</span> document</span></code></div><div class="spec-doc"><p>The abstract type of documents.</p></div></div><h3 id="atomic-documents"><a href="#atomic-documents" class="anchor"></a>Atomic Documents</h3><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>empty</code> is the empty document.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-char"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span>char <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>char c</code> is an atomic document that consists of the single character <code>c</code>. This character must not be a newline character.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>string s</code> is an atomic document that consists of the string <code>s</code>. This string must not contain a newline. The printing engine assumes that the ideal width of this string is <code>String.length s</code>. This assumption is safe if this is an ASCII string. Otherwise, <a href="#val-fancystring"><code>fancystring</code></a> or <a href="#val-utf8string"><code>utf8string</code></a> should be preferred.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-substring"><a href="#val-substring" class="anchor"></a><code><span><span class="keyword">val</span> substring : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>substring s ofs len</code> is an atomic document that consists of the portion of the string <code>s</code> delimited by the offset <code>ofs</code> and the length <code>len</code>. This portion must not contain a newline. <code>substring s ofs len</code> is equivalent to <code>string (String.sub s ofs len)</code>, but is expected to be more efficient, as the substring is not actually extracted.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fancystring"><a href="#val-fancystring" class="anchor"></a><code><span><span class="keyword">val</span> fancystring : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>fancystring s alen</code> is an atomic document that consists of the string <code>s</code>. This string must not contain a newline. The string may contain fancy characters: color escape characters, UTF-8 characters, etc. Thus, its apparent length (which measures how many columns the text will take up on screen) differs from its length in bytes. The printing engine assumes that its apparent length is <code>alen</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fancysubstring"><a href="#val-fancysubstring" class="anchor"></a><code><span><span class="keyword">val</span> fancysubstring : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>fancysubstring s ofs len alen</code> is equivalent to <code>fancystring (String.sub
   s ofs len) alen</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-utf8string"><a href="#val-utf8string" class="anchor"></a><code><span><span class="keyword">val</span> utf8string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>utf8string s</code> is an atomic document that consists of the UTF-8-encoded string <code>s</code>. This string must not contain a newline. <code>utf8string s</code> is equivalent to <code>fancystring s (utf8_length s)</code>, where <code>utf8_length s</code> is the apparent length of the UTF-8-encoded string <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-utf8format"><a href="#val-utf8format" class="anchor"></a><code><span><span class="keyword">val</span> utf8format : <span><span><span>(<span class="type-var">'a</span>, unit, string, <a href="#type-document">document</a>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>utf8format format &lt;args&gt;...</code> is equivalent to <code>utf8string (Printf.sprintf format &lt;args&gt;...)</code>.</p></div></div><h3 id="blanks-and-newlines"><a href="#blanks-and-newlines" class="anchor"></a>Blanks and Newlines</h3><div class="odoc-spec"><div class="spec value anchored" id="val-hardline"><a href="#val-hardline" class="anchor"></a><code><span><span class="keyword">val</span> hardline : <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p>The atomic document <code>hardline</code> represents a forced newline. This document has infinite ideal width: thus, if there is a choice between printing it in flat mode and printing it in normal mode, normal mode is preferred. In other words, when <code>hardline</code> is placed directly inside a group, this group is dissolved: <code>group hardline</code> is equivalent to <code>hardline</code>. This combinator should be seldom used; consider using <a href="#val-break"><code>break</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-blank"><a href="#val-blank" class="anchor"></a><code><span><span class="keyword">val</span> blank : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p>The atomic document <code>blank n</code> consists of <code>n</code> blank characters. A blank character is like an ordinary ASCII space character <code>char ' '</code>, except that blank characters that appear at the end of a line are automatically suppressed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-space"><a href="#val-space" class="anchor"></a><code><span><span class="keyword">val</span> space : <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>space</code> is a synonym for <code>blank 1</code>. It consists of one blank character. It is therefore not equivalent to <code>char ' '</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-break"><a href="#val-break" class="anchor"></a><code><span><span class="keyword">val</span> break : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p>The document <code>break n</code> is a breakable blank of width <code>n</code>. It produces <code>n</code> blank characters if the printing engine is in flat mode, and a single newline character if the printing engine is in normal mode. <code>break 1</code> is equivalent to <code>ifflat (blank 1) hardline</code>.</p></div></div><h3 id="composite-documents"><a href="#composite-documents" class="anchor"></a>Composite Documents</h3><div class="odoc-spec"><div class="spec value anchored" id="val-(^^)"><a href="#val-(^^)" class="anchor"></a><code><span><span class="keyword">val</span> (^^) : <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>doc1 ^^ doc2</code> is the concatenation of the documents <code>doc1</code> and <code>doc2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-group"><a href="#val-group" class="anchor"></a><code><span><span class="keyword">val</span> group : <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>group doc</code> encodes a choice. If the document <code>doc</code> fits on the current line, then it is rendered on a single line, in flat mode. (All <code>group</code> combinators inside it are then ignored.) Otherwise, this group is dissolved, and <code>doc</code> is rendered in normal mode. There might be more groups within <code>doc</code>, whose presence leads to further choices being explored.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ifflat"><a href="#val-ifflat" class="anchor"></a><code><span><span class="keyword">val</span> ifflat : <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>ifflat doc1 doc2</code> is rendered as <code>doc1</code> if the printing engine is in flat mode, that is, if the printing engine has determined that some enclosing group fits on the current line. Otherwise, it is rendered as <code>doc2</code>. Use this combinator with caution! Because the printing engine is free to choose between <code>doc1</code> and <code>doc2</code>, these documents must be semantically equivalent. It is up to the user to enforce this property.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nest"><a href="#val-nest" class="anchor"></a><code><span><span class="keyword">val</span> nest : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p>To render the document <code>nest j doc</code>, the printing engine temporarily increases the current indentation level by <code>j</code>, then renders <code>doc</code>. The effect of the current indentation level is as follows: every time a newline character is emitted, it is immediately followed by <code>n</code> blank characters, where <code>n</code> is the current indentation level. Thus, one may think of <code>nest j doc</code> roughly as the document <code>doc</code> in which <code>j</code> blank characters have been inserted after every newline character.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-align"><a href="#val-align" class="anchor"></a><code><span><span class="keyword">val</span> align : <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p>To render <code>align doc</code>, the printing engine sets the current indentation level to the current column, then renders <code>doc</code>. In other words, the document <code>doc</code> is rendered within a box whose upper left corner is the current position of the printing engine.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-point"><a href="#type-point" class="anchor"></a><code><span><span class="keyword">type</span> point</span><span> = int * int</span></code></div><div class="spec-doc"><p>A point is a pair of a line number and a column number.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-range"><a href="#type-range" class="anchor"></a><code><span><span class="keyword">type</span> range</span><span> = <a href="#type-point">point</a> * <a href="#type-point">point</a></span></code></div><div class="spec-doc"><p>A range is a pair of points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span><span>(<span><a href="#type-range">range</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p>The document <code>range hook doc</code> is printed like the document <code>doc</code>, but allows the caller to register a hook that is applied, when the document is printed, to the range occupied by this document in the output text. This offers a way of mapping positions in the output text back to (sub)documents.</p></div></div><h2 id="inspecting"><a href="#inspecting" class="anchor"></a>Inspecting Documents</h2><p>Documents are abstract, and cannot be inspected. Nevertheless, it is possible to test whether a document is empty.</p><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty doc</code> determines whether the document <code>doc</code> is empty. Most ways of constructing empty documents, such as <code>empty</code>, <code>empty ^^ empty</code>, <code>nest j empty</code>, and so on, are recognized as such. However, a document constructed by <a href="#val-custom"><code>custom</code></a> or <a href="#val-range"><code>range</code></a> is never considered empty.</p></div></div><h2 id="rendering"><a href="#rendering" class="anchor"></a>Rendering Documents</h2><p>Three renderers are available. They offer the same API, described by the signature <a href="module-type-RENDERER/index.html"><code>RENDERER</code></a>, and differ only in the nature of the output channel that they use.</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-RENDERER"><a href="#module-type-RENDERER" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-RENDERER/index.html">RENDERER</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This signature describes the document renderers in a manner that is independent of the type of the output channel.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-ToChannel"><a href="#module-ToChannel" class="anchor"></a><code><span><span class="keyword">module</span> <a href="ToChannel/index.html">ToChannel</a></span><span> : 
  <a href="module-type-RENDERER/index.html">RENDERER</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-RENDERER/index.html#type-channel">channel</a> = <span class="xref-unresolved">Stdlib</span>.out_channel</span> <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-RENDERER/index.html#type-document">document</a> = <a href="#type-document">document</a></span></span></code></div><div class="spec-doc"><p>This renderer sends its output into an output channel.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-ToBuffer"><a href="#module-ToBuffer" class="anchor"></a><code><span><span class="keyword">module</span> <a href="ToBuffer/index.html">ToBuffer</a></span><span> : 
  <a href="module-type-RENDERER/index.html">RENDERER</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-RENDERER/index.html#type-channel">channel</a> = <span class="xref-unresolved">Stdlib</span>.Buffer.t</span> <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-RENDERER/index.html#type-document">document</a> = <a href="#type-document">document</a></span></span></code></div><div class="spec-doc"><p>This renderer sends its output into a memory buffer.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-ToFormatter"><a href="#module-ToFormatter" class="anchor"></a><code><span><span class="keyword">module</span> <a href="ToFormatter/index.html">ToFormatter</a></span><span> : 
  <a href="module-type-RENDERER/index.html">RENDERER</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-RENDERER/index.html#type-channel">channel</a> = <span class="xref-unresolved">Stdlib</span>.Format.formatter</span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-RENDERER/index.html#type-document">document</a> = <a href="#type-document">document</a></span></span></code></div><div class="spec-doc"><p>This renderer sends its output into a formatter channel.</p></div></div><h2 id="defining"><a href="#defining" class="anchor"></a>Defining Custom Documents</h2><p>It is possible to define custom document constructors, provided they meet the expectations of the printing engine. In short, the custom document combinator <a href="#val-custom"><code>custom</code></a> expects an object of class <a href="class-type-custom/index.html"><code>custom</code></a>. This object must provide three methods. The method <code>requirement</code> must compute the ideal width of the custom document. The methods <code>pretty</code> and <code>compact</code> must render the custom document. For this purpose, they have access to the <a href="class-type-output/index.html" title="output">output channel</a> and to the <a href="#type-state" title="state">state</a> of the printing engine.</p><div class="odoc-spec"><div class="spec type anchored" id="type-requirement"><a href="#type-requirement" class="anchor"></a><code><span><span class="keyword">type</span> requirement</span><span> = int</span></code></div><div class="spec-doc"><p>A width requirement is expressed as an integer. The value <code>max_int</code> is reserved and represents infinity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-infinity"><a href="#val-infinity" class="anchor"></a><code><span><span class="keyword">val</span> infinity : <a href="#type-requirement">requirement</a></span></code></div><div class="spec-doc"><p><code>infinity</code> represents an infinite width requirement.</p></div></div><div class="odoc-spec"><div class="spec class-type anchored" id="class-type-output"><a href="#class-type-output" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">type</span>  </span><span><a href="class-type-output/index.html">output</a></span><span> = <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An output channel is abstractly represented as an object equipped with methods for displaying one character and for displaying a substring.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-state"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span><span> = </span><span>{</span></code><ol><li id="type-state.width" class="def record field anchored"><a href="#type-state.width" class="anchor"></a><code><span>width : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The line width. This parameter is fixed throughout the execution of the renderer.</p><span class="comment-delim">*)</span></div></li><li id="type-state.ribbon" class="def record field anchored"><a href="#type-state.ribbon" class="anchor"></a><code><span>ribbon : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The ribbon width. This parameter is fixed throughout the execution of the renderer.</p><span class="comment-delim">*)</span></div></li><li id="type-state.last_indent" class="def record field anchored"><a href="#type-state.last_indent" class="anchor"></a><code><span><span class="keyword">mutable</span> last_indent : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The number of blanks that were printed at the beginning of the current line. This field is updated (only) when a hardline is emitted. It is used (only) to determine whether the ribbon width constraint is respected.</p><span class="comment-delim">*)</span></div></li><li id="type-state.line" class="def record field anchored"><a href="#type-state.line" class="anchor"></a><code><span><span class="keyword">mutable</span> line : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The current line. This field is updated (only) when a hardline is emitted. It is not used by the pretty-printing engine itself.</p><span class="comment-delim">*)</span></div></li><li id="type-state.column" class="def record field anchored"><a href="#type-state.column" class="anchor"></a><code><span><span class="keyword">mutable</span> column : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The current column. This field must be updated whenever something is sent to the output channel. It is used (only) to determine whether the width constraint is respected.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The internal state of the rendering engine is exposed to the user who wishes to define custom documents. However, its structure is subject to change in future versions of the library.</p></div></div><div class="odoc-spec"><div class="spec class-type anchored" id="class-type-custom"><a href="#class-type-custom" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">type</span>  </span><span><a href="class-type-custom/index.html">custom</a></span><span> = <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A custom document is defined by implementing an object of class <a href="class-type-custom/index.html"><code>custom</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-custom"><a href="#val-custom" class="anchor"></a><code><span><span class="keyword">val</span> custom : <span><a href="class-type-custom/index.html">custom</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-document">document</a></span></code></div><div class="spec-doc"><p><code>custom</code> constructs a custom document out an object of type <a href="class-type-custom/index.html"><code>custom</code></a>.</p></div></div><p>Some of the key functions of the library are exposed, in the hope that they may be useful to authors of custom (leaf and composite) documents. In the case of a leaf document, they can help perform certain basic functions; for instance, applying the function <a href="#val-pretty"><code>pretty</code></a> to the document <a href="#val-hardline"><code>hardline</code></a> is a simple way of printing a hardline, while respecting the indentation parameters and updating the state in a correct manner. Similarly, applying <a href="#val-pretty"><code>pretty</code></a> to the document <code>blank n</code> is a simple way of printing <code>n</code> blank characters. In the case of a composite document (one that contains subdocuments), these functions are essential: they allow computing the width requirement of a subdocument and displaying a subdocument.</p><div class="odoc-spec"><div class="spec value anchored" id="val-requirement"><a href="#val-requirement" class="anchor"></a><code><span><span class="keyword">val</span> requirement : <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-requirement">requirement</a></span></code></div><div class="spec-doc"><p><code>requirement doc</code> computes the width requirement of the document <code>doc</code>. It runs in constant time.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty"><a href="#val-pretty" class="anchor"></a><code><span><span class="keyword">val</span> pretty : <span><a href="class-type-output/index.html">output</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pretty output state indent flatten doc</code> prints the document <code>doc</code>. See the documentation of the method <code>pretty</code> in the class <a href="class-type-custom/index.html"><code>custom</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compact"><a href="#val-compact" class="anchor"></a><code><span><span class="keyword">val</span> compact : <span><a href="class-type-output/index.html">output</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-document">document</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>compact output doc</code> prints the document <code>doc</code>. See the documentation of the method <code>compact</code> in the class <a href="class-type-custom/index.html"><code>custom</code></a>.</p></div></div></div></body></html>
